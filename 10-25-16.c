#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  fl,             sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rl,             sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  fr,             sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  rr,             sensorQuadEncoder)
#pragma config(Motor,  port2,           rlMotor,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           flMotor,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           frMotor,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           rrMotor,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


//Puertos 3 y 4 front, 3 izquierda, 4 derecha
//Puertos 2 y 5 rear, 2 izquierda, 5 derecha

#include "BNSLib.h";

int encoderL, encoderR, counter;

void moveBase(int speed)
{
	motor[flMotor]=speed;
	motor[rlMotor]=speed;
	motor[frMotor]=speed;
	motor[rrMotor]=speed;
}

void moveBase(int speed, int offset)
{
	motor[flMotor]=speed - offset;
	motor[rlMotor]=speed - offset;
	motor[frMotor]=speed + offset;
	motor[rrMotor]=speed + offset;
}

float ticksToInches(int ticks)
{
	float inches = ticks*((2.75*PI)/360.0)/0.9;
	return inches;
}

float inchesToTicks(int inches)
{
	float ticks = inches*(360.0/(2.75*PI))*0.9;
	return ticks;
}

task posSys()
{
	float flx = 0, fly = 0, frx = 0, fry = 0, rlx = 0, rly = 0, rrx = 0, rry = 0, x = 0, y = 0;
	float gyroValue = 0;
	float gyroOffset = 90.0;
	int fl_enc = 0, fr_enc = 0, rl_enc = 0, rr_enc = 0;
	int fl_enc_last = 0, fr_enc_last = 0, rl_enc_last = 0, rr_enc_last = 0;
	float cosValue = 0, sinValue = 0;
	while(1)
	{
		gyroValue = -SensorValue[gyro]/10.0 + gyroOffset;

		fl_enc = -SensorValue[fl];
		fr_enc = -SensorValue[fr];
		rl_enc = SensorValue[rl];
		rr_enc = -SensorValue[rr];

		cosValue = cosDegrees(gyroValue);
		sinValue = sinDegrees(gyroValue);

		flx = (fl_enc-fl_enc_last)*cosValue;
		fly = (fl_enc-fl_enc_last)*sinValue;
		frx = (fr_enc-fr_enc_last)*cosValue;
		fry = (fr_enc-fr_enc_last)*sinValue;
		rlx = (rl_enc-rl_enc_last)*cosValue;
		rly = (rl_enc-rl_enc_last)*sinValue;
		rrx = (rr_enc-rr_enc_last)*cosValue;
		rry = (rr_enc-rr_enc_last)*sinValue;

		x = x + (flx+frx+rlx+rrx)/4.0;
		y = y + (fly+fry+rly+rry)/4.0;

		fl_enc_last = fl_enc;
		fr_enc_last = fr_enc;
		rl_enc_last = rl_enc;
		rr_enc_last = rr_enc;

		writeDebugStreamLine("x = %f, y = %f", ticksToInches(x), ticksToInches(y));
		//writeDebugStreamLine("fl = %f, fr = %f, rl = %f, rr = %f", fl_enc, fr_enc, rl_enc, rr_enc);
		//writeDebugStreamLine("gyro = %f", gyroValue);

		wait1Msec(50);
	}
}

//Distance in inches
void moveBaseWithFactor(int distance, int time, float factor){
	distance = inchesToTicks(distance);
	writeDebugStreamLine("Start moveBaseFront");
	writeDebugStreamLine("Target distance = %d", distance);
	int encoderAvg = 0;
	encoderR = 0;
	encoderL = 0;
	float initialGyro = SensorValue[gyro], actualGyro = initialGyro;
	writeDebugStreamLine("Initial Gyro Position = %f", initialGyro);
	int startEncoderValueR = SensorValue[rr];
	int startEncoderValueL = SensorValue[rl];
	bool atPos=false;
	float pidMovResult;
	//float pidStraightResult;
	counter = 0;

	PID pidMovement;
	//PID pidStraight;
	PIDInit(&pidMovement, 0.5, .1, 0.25); // Set P, I, and D constants
	//PIDInit(&pidStraight, 2, 0, 0.3);//Set constants for driving straight

	clearTimer(T1);
	int timer = T1;
	while(!atPos && timer < time){
		encoderR = (SensorValue[rr] - startEncoderValueR)*-1;//Reversing
		encoderL = SensorValue[rl] - startEncoderValueL;
		encoderAvg = (encoderR+encoderL)/2;
		writeDebugStreamLine("encR = %d\tencL = %d", encoderR, encoderL);
		pidMovResult = PIDCompute(&pidMovement, distance - encoderAvg);
		//pidStraightResult = PIDCompute(&pidStraight, initialGyro - actualGyro);
		//writeDebugStreamLine("Actual Gyro Position = %f   PID = %f", actualGyro, pidStraightResult);
		if(initialGyro > actualGyro)
			moveBase((pidMovResult*factor), -40);
		else if(initialGyro < actualGyro)
			moveBase((pidMovResult*factor), 40);
		else
			moveBase(pidMovResult*factor);
		if (abs(encoderAvg-distance)<2)
			counter++;
		if (counter >= 4)
			atPos = true;
		timer = time1[T1];
		wait1Msec(25);
		actualGyro = SensorValue[gyro];
	}
	moveBase(0);
	writeDebugStreamLine("Encoder at position = %d", encoderAvg);
}

task main()
{
	BNS();
	////Initialize Gyro
	//SensorType[gyro] = sensorNone;
	//wait1Msec(1000);
	//SensorType[gyro] = sensorGyro;
	//wait1Msec(2000);
	////End Initialize Gyro

	SensorValue[fl] = 0;
	SensorValue[fr] = 0;
	SensorValue[rl] = 0;
	SensorValue[rr] = 0;


	//startTask(posSys);

	//moveBase(50);
	//wait1Msec(1000);
	//moveBase(0);
	//wait1Msec(050);
	//moveBase(-50);
	//wait1Msec(1000);
	//moveBase(0);
	moveBaseWithFactor(36, 3000, .5);
}
