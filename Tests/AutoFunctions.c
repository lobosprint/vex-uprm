#pragma config(Sensor, in1,    potTower,       sensorPotentiometer)
#pragma config(Sensor, in2,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  gripperRight,   sensorNone)
#pragma config(Sensor, dgtl2,  gripperLeft,    sensorNone)
#pragma config(Sensor, dgtl3,  encR,           sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  encL,           sensorQuadEncoder)
#pragma config(Motor,  port1,           rbBase,        tmotorVex393HighSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           riTower,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           rfBase,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           rmBase,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           roTower,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           lfBase,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           lmBase,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           loTower,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           liTower,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          lbBase,        tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//r = right, l = left, b = back, m = middle, f = front, i = inner, o = outer

//*********************************************************************************************
//			Includes
//*********************************************************************************************

#include "BNSLib.h";

//*********************************************************************************************
//			Gripper Functions
//*********************************************************************************************

//Request 1 for open the gripper and 0 for close the gripper
//Sides linked mechanically
void gripperAction(int action, int gripperPotInit)
{
	motor[gripperLeft] = 0;
	motor[gripperRight] = 0;
	int gripperPotVal = SensorValue[gripperPot];
	bool move = true;
	if (action == 1)
	{
		//Si la pinza aun no esta abierta del todo o la pinza no puede moverse entonces sigue abriendose
		while ((gripperPotVal - gripperPotInit) < 1000)
		{
			//writeDebugStreamLine("Gripper = %d", (gripperPotVal - gripperPotInit));
			motor[gripperLeft] = 127;
			motor[gripperRight] = 127;
			delay(40);
			gripperPotVal = SensorValue[gripperPot];
		}

		motor[gripperLeft] = 0;
		motor[gripperRight] = 0;
	}
	else if (action == 0)
	{
		//writeDebugStreamLine("Valor del while tiene que ser > 1: %d", (gripperPotVal - gripperPotInit));
		while ((gripperPotVal - gripperPotInit) > 1 && move)
		{
			//writeDebugStreamLine("Valor %d > Valor %d", gripperPotVal, SensorValue[gripperPot] - 50);
			//Si la pinza no puede abrirse más entonces se para el movimiento, se aumenta el umbral en 10 que es la oscilación aproximada que tiene el sensar
			if (gripperPotVal > SensorValue[gripperPot] + 50) {
				move = false;
			}
			else
			{
				//writeDebugStreamLine("Gripper  = %d", (gripperPotVal - gripperPotInit));
				gripperPotVal = SensorValue[gripperPot];
				motor[gripperLeft] = -127;
				motor[gripperRight] = -127;
			}
			delay(50);
		}

		motor[gripperLeft] = -30;
		motor[gripperRight] = -30;
	}
}

//Close gripper
//Two sides at the same time with two potentiometers
void gripperClose(int gripperLeftInit, int gripperRightInit)
{
	motor[gripperLeft] = 127;
	delay(10);
	int gripperLeftVal = SensorValue[gripperPotLeft];
	int gripperRightVal = SensorValue[gripperPotRight];
	if ((gripperLeftInit - gripperLeftVal ) < (gripperRightInit - gripperRightVal))
	{
		motor[gripperRight] = 127;
		delay(10);
	}
	else
	{
		motor[gripperRight] = 0;
	}
}

//Open gripper
//Two sides at the same time with two potentiometers
void gripperOpen(int gripperLeftInit, int gripperRightInit)
{
	motor[gripperLeft] = -127;
	delay(10);
	int gripperLeftVal = SensorValue[gripperPotLeft];
	int gripperRightVal = SensorValue[gripperPotRight];
	//writeDebugStreamLine("((%d - %d) > (%d - %d))", gripperLeftInit, gripperLeftVal, gripperRightInit, gripperRightVal);
	if ((gripperLeftInit - gripperLeftVal ) > (gripperRightInit - gripperRightVal))
	{
		motor[gripperRight] = -127;
		delay(10);
	}
	else
	{
		motor[gripperLeft] = 0;
	}
}

//*********************************************************************************************
//			Arm Functions
//*********************************************************************************************

//Up the arm, open the gripper and down the arm
void armThrow(int armPotInit, int gripperPotInit)
{
	int armPotVal = SensorValue[armPot];
	bool throw = true;
	//up the arm
	while ((armPotVal - armPotInit) < 2200)
	{
		writeDebugStreamLine("Condición %d > 2000", (armPotVal - armPotInit));
		motor[armTopLeft] = 127;
		motor[armTopRight] = 127;
		motor[armBottomLeft] = 127;
		motor[armBottomRight] = 127;
		delay(50);
		armPotVal = SensorValue[armPot];

		if((armPotVal - armPotInit) > 1700 && throw)
		{
			//Open gipper
			gripperAction(1,gripperPotInit);
			throw = false;
		}
	}

	//Down the arm
	while ((armPotVal - armPotInit) > 200)
	{
		writeDebugStreamLine("Condición %d < 200", (armPotVal - armPotInit));
		motor[armTopLeft] = -127;
		motor[armTopRight] = -127;
		motor[armBottomLeft] = -127;
		motor[armBottomRight] = -127;
		delay(50);
		armPotVal = SensorValue[armPot];
	}

	motor[armTopLeft] = 0;
	motor[armTopRight] = 0;
	motor[armBottomLeft] = 0;
	motor[armBottomRight] = 0;
}

//*********************************************************************************************
//			Base Functions
//*********************************************************************************************

int encoderL, encoderR, counter;

void moveBase(int speed)
{
	motor[flMotor]=speed;
	motor[rlMotor]=speed;
	motor[frMotor]=speed;
	motor[rrMotor]=speed;
}

void moveBase(int speed, int offset)
{
	motor[flMotor]=speed - offset;
	motor[rlMotor]=speed - offset;
	motor[frMotor]=speed + offset;
	motor[rrMotor]=speed + offset;
}

float ticksToInches(int ticks)
{
	float inches = ticks*((2.75*PI)/360.0)/0.9;
	return inches;
}

float inchesToTicks(int inches)
{
	float ticks = inches*(360.0/(2.75*PI))*0.9;
	return ticks;
}

task posSys()
{
	float flx = 0, fly = 0, frx = 0, fry = 0, rlx = 0, rly = 0, rrx = 0, rry = 0, x = 0, y = 0;
	float gyroValue = 0;
	float gyroOffset = 90.0;
	int fl_enc = 0, fr_enc = 0, rl_enc = 0, rr_enc = 0;
	int fl_enc_last = 0, fr_enc_last = 0, rl_enc_last = 0, rr_enc_last = 0;
	float cosValue = 0, sinValue = 0;
	while(1)
	{
		gyroValue = -SensorValue[gyro]/10.0 + gyroOffset;

		fl_enc = -SensorValue[fl];
		fr_enc = -SensorValue[fr];
		rl_enc = SensorValue[rl];
		rr_enc = -SensorValue[rr];

		cosValue = cosDegrees(gyroValue);
		sinValue = sinDegrees(gyroValue);

		flx = (fl_enc-fl_enc_last)*cosValue;
		fly = (fl_enc-fl_enc_last)*sinValue;
		frx = (fr_enc-fr_enc_last)*cosValue;
		fry = (fr_enc-fr_enc_last)*sinValue;
		rlx = (rl_enc-rl_enc_last)*cosValue;
		rly = (rl_enc-rl_enc_last)*sinValue;
		rrx = (rr_enc-rr_enc_last)*cosValue;
		rry = (rr_enc-rr_enc_last)*sinValue;

		x = x + (flx+frx+rlx+rrx)/4.0;
		y = y + (fly+fry+rly+rry)/4.0;

		fl_enc_last = fl_enc;
		fr_enc_last = fr_enc;
		rl_enc_last = rl_enc;
		rr_enc_last = rr_enc;

		writeDebugStreamLine("x = %f, y = %f", ticksToInches(x), ticksToInches(y));
		//writeDebugStreamLine("fl = %f, fr = %f, rl = %f, rr = %f", fl_enc, fr_enc, rl_enc, rr_enc);
		//writeDebugStreamLine("gyro = %f", gyroValue);

		wait1Msec(50);
	}
}

//Distance in inches
void moveBaseWithFactor(int distance, int time, float factor){
	distance = inchesToTicks(distance);
	writeDebugStreamLine("Start moveBaseFront");
	writeDebugStreamLine("Target distance = %d", distance);
	int encoderAvg = 0;
	encoderR = 0;
	encoderL = 0;
	float initialGyro = SensorValue[gyro], actualGyro = initialGyro;
	writeDebugStreamLine("Initial Gyro Position = %f", initialGyro);
	int startEncoderValueR = SensorValue[rr];
	int startEncoderValueL = SensorValue[rl];
	bool atPos=false;
	float pidMovResult;
	//float pidStraightResult;
	counter = 0;

	PID pidMovement;
	//PID pidStraight;
	PIDInit(&pidMovement, 0.5, .1, 0.25); // Set P, I, and D constants
	//PIDInit(&pidStraight, 2, 0, 0.3);//Set constants for driving straight

	clearTimer(T1);
	int timer = T1;
	while(!atPos && timer < time){
		encoderR = (SensorValue[rr] - startEncoderValueR)*-1;//Reversing
		encoderL = SensorValue[rl] - startEncoderValueL;
		encoderAvg = (encoderR+encoderL)/2;
		writeDebugStreamLine("encR = %d\tencL = %d", encoderR, encoderL);
		pidMovResult = PIDCompute(&pidMovement, distance - encoderAvg);
		//pidStraightResult = PIDCompute(&pidStraight, initialGyro - actualGyro);
		//writeDebugStreamLine("Actual Gyro Position = %f   PID = %f", actualGyro, pidStraightResult);
		if(initialGyro > actualGyro)
			moveBase((pidMovResult*factor), -40);
		else if(initialGyro < actualGyro)
			moveBase((pidMovResult*factor), 40);
		else
			moveBase(pidMovResult*factor);
		if (abs(encoderAvg-distance)<2)
			counter++;
		if (counter >= 4)
			atPos = true;
		timer = time1[T1];
		wait1Msec(25);
		actualGyro = SensorValue[gyro];
	}
	moveBase(0);
	writeDebugStreamLine("Encoder at position = %d", encoderAvg);
}

//*********************************************************************************************
//			Other Functions
//*********************************************************************************************
void init()
{
	BNS();

	//Initialize Gyro
	SensorType[gyro] = sensorNone;
	wait1Msec(1000);
	SensorType[gyro] = sensorGyro;
	wait1Msec(2000);
	//End Initialize Gyro

	SensorValue[fl] = 0;
	SensorValue[fr] = 0;
	SensorValue[rl] = 0;
	SensorValue[rr] = 0;
}

//*********************************************************************************************
//			Main Task
//*********************************************************************************************

task main()
{
	init();

}
